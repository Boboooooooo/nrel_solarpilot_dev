from math import pi
import datetime

is_custom_rec = False

td = datetime.date.today()
stamp = "//File automatically generated by variable_map_makefile.py {}/{}/{}\n".format(td.year, td.month, td.day)

flines = [line.replace("\n","").split('\t') for line in open("variable_definitions.txt",'r').readlines()]

tmap = {"MATRIX_T":"matrix_t<double>",
        "BOOL":"bool",
        "STRING":"std::string",
        "INT":"int",
        "DOUBLE":"double",
        "WEATHERDATA":"WeatherData",
        "VEC_DOUBLE":"std::vector< double >",
        "VEC_INTEGER":"std::vector< int >",
        "DVEC_POINT":"std::vector<std::vector<Point> >",
        "VOIDPTR":"void*"
        }

dmap = {}

#Group lines by domain
for line in flines:
    try:
        dmap[line[0]].append( line )
    except:
        dmap[line[0]] = [line]   
        
#header file preamble
#defpath = "../../ssc_dev/solarpilot/"
defpath = "../../ssc/solarpilot/"
deffileh = defpath + "definitions.h"
deffilec = defpath + "definitions.cpp"

fdh = open(deffileh, 'w')
fdh.write(stamp)

fdh.write( \
"""
#ifndef _VARDEFS_
#define _VARDEFS_ 1

#include "mod_base.h"
#include "Toolbox.h"

#ifdef _MSC_VER
#pragma warning(disable : 4267)
#endif

//Enumeration of data columns in the variable map file


//Custom module settings
#define _CUSTOM_REC %d		//If using custom geometry functions in the CustomReceiverWindow, define 1
//Sandbox mode
#define _SANDBOX 0
//demo only
#define _DEMO 0	//Is this a demo version?
const int _demo_date[] = {2014,8,1};
//Include Coretrace (relevant to fieldcore only! Disabling this option will cause SolarPILOT compilation to fail.).
#ifdef SP_STANDALONE
	#define SP_USE_SOLTRACE
	//Compile without threading functionality? Comment out to remove.
	#define SP_USE_THREADS
	//crete local make-dir functions
	#ifdef _WIN32 
	    #define SP_USE_MKDIR
	#endif
#endif

#ifndef PI
    #define PI %.20f
    #define R2D %.20f
    #define D2R %.20f
#endif

"""%(1 if is_custom_rec else 0, pi, 180./pi, pi/180.)
)

domains = dmap.keys()
domains.sort()

for domain in domains:
    fdh.write("\n\n")
    if domain == "custom_rec":
        fdh.write("#if _CUSTOM_REC\n")
    
    fdh.write("struct var_"+domain + "\n{\n")
    
    #sort each domain by inout type then variable name
    dmap[domain].sort(key = lambda x: x[1])    
    dmap[domain].sort(key = lambda x: x[2])
    
    for var in dmap[domain]:
        tp = "spvar" if var[2] == "IN" else "spout"
        fdh.write( "\t%s< "%tp + tmap[var[3]] + " > " + var[1] + "; \t\t//[" + var[5] + "] " + var[11] + "\n" )
        if var[7] == "combo":
            copts = var[8].split(";")
            enstr = "struct "+var[1].upper()+"{ enum EN{%s}; };\n"
            entries = []
            for copt in copts:
                if copt == "":
                    continue
                ename, ev = copt.split("=")
                escrub = ''.join(e for e in ename if (e.isalnum() or e==' '))
                ename = escrub.replace(" ","_").upper()
                if ename[0].isdigit():
                    ename = "N" + ename
                entries.append(ename + "=" + ev)
            fdh.write("\t" + enstr%(",".join(entries)))
                
    fdh.write(\
    """
    void addptrs(unordered_map<std::string, spbase*> &pmap);\n"""
    )
    
    fdh.write("};\n") 
    
    if domain == "custom_rec":
        fdh.write("#endif\n")


fdh.write(\
"""

struct var_map
{
    var_ambient amb;
    var_financial fin;
    var_fluxsim flux;
    var_land land;
    var_optimize opt;
    var_parametric par;
    var_plant plt;
    var_solarfield sf;
#if _CUSTOM_REC    
    var_custom_rec crec;    
#endif
    
    std::vector< var_heliostat > hels;
    std::vector< var_receiver > recs;
   
    var_map();
    var_map( var_map &vc );   
    void copy( var_map &vc );
    void reset();

    unordered_map<std::string, spbase*> _varptrs;
    void add_receiver(int id);
    void add_heliostat(int id);
    void drop_receiver(int id);
    void drop_heliostat(int id);
};
""")

fdh.write("\n#endif\n")
fdh.close()

#---------------------------------------------------------------------
#  Write cpp file
#---------------------------------------------------------------------
imap = {\
    "ambient":"amb",
    "custom_rec":"crec",
    "financial":"fin",
    "fluxsim":"flux",
    "heliostat":"hels.back()",
    "land":"land",
    "optimize":"opt",
    "parametric":"par",
    "plant":"plt",
    "receiver":"recs.back()",
    "solarfield":"sf"
}

fdc = open(deffilec,'w')

fdc.write(stamp)

fdc.write(\
"""
#include "definitions.h"
#include "mod_base.h"
#include "string_util.h"

var_map::var_map()
{
    reset();
}

var_map::var_map( var_map &vc )
{
    reset();
    copy( vc );
}

void var_map::copy( var_map &vc )
{
    for( unordered_map< std::string, spbase* >::iterator var=_varptrs.begin(); var!=_varptrs.end(); var++ )
        var->second->set_from_string( vc._varptrs.at( var->first )->as_string().c_str() );
    
    return;
}

void var_map::reset()
{
    //first clear the receiver and heliostat objects
    hels.clear();
    recs.clear();
    //clear out pointer map
    _varptrs.clear();
    
    //reserve size for the templates. otherwise, the pointer addresses get confused. This is the max limit of templates.
    hels.reserve(100);
    recs.reserve(100);
    
"""
)

sc = "\""

dmain = [s for s in domains]
dmain.remove("heliostat")
dmain.remove("receiver")

"""
std::string Address, 
SP_DATTYPE Dtype, 
std::string Value, 
std::string Units, 
bool Is_param, 
std::string Ctrl, 
std::string Special,
bool UI_disable,
std::string Label,
std::string Description
"""

"""
0	Domain
1	String name
2	INOUT
3	Type
4	Value
5	Units
6	Parameterizable?
7	Control
8	Special
9	UI Disable
10	Label
11	Description
"""

def wrtvar(domain, var, sep):
    if var[2] == "IN":
        fdc.write("\t%-33s.set(%-35s, %-25s, %20s, %12s, %8s, %10s, %5s, %8s, %40s, %s);\n"%\
            tuple([
                    imap[domain]+"."+var[1],  #instance name. variable name
                    #-------------------
                    sc+var[0]+"."+sep+"."+var[1]+sc,  #address
                    "SP_DATTYPE::SP_"+var[3],  #data type
                    sc+var[4]+sc, #value
                    sc+var[5]+sc, #units
#                        sc+var[6]+sc, #range
                    var[6].lower(),  #parameterizable
                    sc+var[7]+sc, #control
                    sc+var[8]+sc, #special args
                    "true" if var[9].lower() == 'x' else "false",  #UI disable
                    sc+var[10]+sc,  #label
                    sc+var[11]+sc  #description
                    ])        
                )
    else:
        fdc.write("\t%-33s.setup(%-35s, %-25s, %13s %20s, %8s, %10s, %5s, %8s, %40s, %s);\n"%\
            tuple([
                    imap[domain]+"."+var[1],  #instance name. variable name
                    #-------------------
                    sc+var[0]+"."+sep+"."+var[1]+sc,  #address
                    "SP_DATTYPE::SP_"+var[3],  #data type
                    " ",
                    sc+var[5]+sc, #units
#                        sc+var[6]+sc, #range
                    var[6].lower(),  #parameterizable
                    sc+var[7]+sc, #control
                    sc+var[8]+sc, #special args
                    "true" if var[9].lower() == 'x' else "false",  #UI disable
                    sc+var[10]+sc,  #label
                    sc+var[11]+sc  #description
                    ])        
                )




for domain in dmain:
    if domain == "custom_rec":
        fdc.write("#if _CUSTOM_REC\n")
    for var in dmap[domain]:
        wrtvar(domain, var, "0")
    if domain == "custom_rec":
        fdc.write("#endif\n")
    fdc.write("\n")

for domain in dmain:
    if domain == "custom_rec":
        fdc.write("#if _CUSTOM_REC\n")
    fdc.write("\t"+imap[domain]+".addptrs( _varptrs );\n")
    if domain == "custom_rec":
        fdc.write("#endif\n")
    
fdc.write(\
    """
    add_heliostat(0);
    add_receiver(0);
    \n""")

fdc.write("}\n\n")


for domain in ['heliostat','receiver']:
    fdc.write("void var_map::add_{}(int id)\n{}\n\tstd::string sid=my_to_string(id);\n".format(domain,"{") )
    fdc.write("\t{}.push_back(var_{}());\n\n".format('hels' if domain == 'heliostat' else 'recs', domain))
    for var in dmap[domain]:
        wrtvar(domain, var, sc+"+sid+"+sc)
    fdc.write("\n\t"+imap[domain]+".id.val = id;")
    fdc.write("\n\t"+imap[domain]+".addptrs( _varptrs );\n")
    fdc.write("}\n\n")



for domain in domains:
    if domain == "custom_rec":
        fdc.write("#if _CUSTOM_REC\n")
    
    fdc.write("void var_{}::addptrs(unordered_map<std::string, spbase*> &pmap)\n{}\n".format(domain,"{"))
    if domain in ['heliostat','receiver']:
        fdc.write("\tstd::string sid = my_to_string(id.val);\n")
        sep = ".\"+sid+\"."
    else:
        sep = ".0."
        
    for var in dmap[domain]:
#        if var[2] == "IN":
        fdc.write("\tpmap[\"{}{}{}\"] = &{};\n".format(var[0], sep, var[1], var[1] ))
    
    fdc.write("}\n")
    
    if domain == "custom_rec":
        fdc.write("#endif\n")
        
    fdc.write("\n")

fdc.write(\
"""
void var_map::drop_receiver(int id)
{
    //find the receiver in the list
    int id_ind=-1;
    for( int i=0; i<recs.size(); i++)
    {
        if( recs.at(i).id.val == id )
        {
            id_ind = i;
            break;
        }
    }
    if( id_ind < 0 )
        throw spexception("Attempting to remove a receiver ID that doesn't exist!");

    //remove var ptrs
    std::string pat = "receiver.";

    unordered_map<std::string, spbase*>::iterator it = _varptrs.begin();
    while( it != _varptrs.end() )
    {
        if( it->first.find( pat ) != std::string::npos )
        {
            it = _varptrs.erase( it );
        }
        else
        {
            it++;
        }
    }
    
    //remove the variable structure
    recs.erase( recs.begin() + id_ind );

    //add back all receiver pointers
    for(int i=0; i<recs.size(); i++)
    {
        recs.at(i).addptrs(_varptrs);
    }    
}

void var_map::drop_heliostat(int id)
{
    //find the heliostat in the list
    int id_ind=-1;
    for( int i=0; i<hels.size(); i++)
    {
        if( hels.at(i).id.val == id )
        {
            id_ind = i;
            break;
        }
    }
    if( id_ind < 0 )
        throw spexception("Attempting to remove a heliostat ID that doesn't exist!");

    //remove var ptrs
    std::string pat = "heliostat.";

    unordered_map<std::string, spbase*>::iterator it = _varptrs.begin();
    while( it != _varptrs.end() )
    {
        if( it->first.find( pat ) != std::string::npos )
        {
            it = _varptrs.erase( it );
        }
        else
        {
            it++;
        }
    }
    
    //remove the variable structure
    hels.erase( hels.begin() + id_ind );

    //add back all heliostat pointers
    for(int i=0; i<hels.size(); i++)
    {
        hels.at(i).addptrs(_varptrs);
    }
}
"""
)

fdc.close()